var e,t;e=this,t=function(){return function(e){var t={};function i(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=e,i.c=t,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)i.d(r,s,function(t){return e[t]}.bind(null,s));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=1)}([function(e){e.exports=JSON.parse('{"name":"albedo-intent","version":"0.8.1","description":"A lightweight browser wrapper for Albedo API that provides a promise-based interface for all supported intents.","author":"StellarExpertTeam<info@stellar.expert>","license":"MIT","homepage":"https://github.com/stellar-expert/albedo","bugs":{"url":"https://github.com/stellar-expert/albedo/issues","email":"info@stellar.expert"},"repository":{"type":"git","url":"https://github.com/stellar-expert/albedo.git"},"scripts":{"postbuild":"node ./build/update-readme.js","build":"webpack --mode=production --config ./webpack.config.js"},"main":"./lib/albedo.intent.js","module":"./src/index.js","keywords":["stellar","SSO","signer","intent","multi-sig"],"devDependencies":{"@babel/core":"^7.10.1","@babel/plugin-proposal-class-properties":"^7.10.1","@babel/plugin-proposal-decorators":"^7.10.1","@babel/plugin-proposal-object-rest-spread":"^7.10.1","@babel/plugin-proposal-private-methods":"^7.10.1","@babel/plugin-syntax-dynamic-import":"^7.8.3","@babel/preset-env":"^7.10.1","@babel/register":"^7.10.1","@purtuga/esm-webpack-plugin":"^1.2.1","babel-loader":"^8.1.0","chai":"^4.2.0","esm":"^3.2.25","mocha":"^7.2.0","sinon":"^9.0.2","terser-webpack-plugin":"^2.3.6","webpack":"^4.43.0","webpack-cli":"^3.3.11"}}')},function(e,t,i){e.exports=i(2)},function(e,t,i){"use strict";function r(){const e=[];for(let t=0;t<4;t++)e.push(Math.random().toString(36).slice(2));return e.join("")}i.r(t),i.d(t,"intentInterface",(function(){return s})),i.d(t,"intentErrors",(function(){return n}));var s={public_key:{risk:"low",title:"View public key",description:"Requests account public key. It's a simple way of authentication for Stellar-based applications. The response ensures that a user owns the corresponding secret key.",unsafe:!1,implicitFlow:!1,params:{token:{description:"Verification token generated by the application (should be unique or random).",required:!1}},returns:["pubkey","token","token_signature"]},sign_message:{risk:"medium",title:"Sign text message",description:"Requests arbitrary message signing. Can be used to implement identity/ownership verification.",unsafe:!1,implicitFlow:!0,params:{message:{description:"Text message to sign.",required:!0},pubkey:{description:"Specific public key requested by the application.",required:!1}},returns:["pubkey","message","original_message","message_signature"]},tx:{risk:"high",title:"Sign transaction",description:"Requests a signature for the transaction. Returns signed transaction envelope that can be submitted to the network or used for multi-sig coordination.",unsafe:!0,implicitFlow:!0,params:{xdr:{description:"XDR-encoded transaction envelope to sign.",required:!0},pubkey:{description:"Specific public key requested by the application.",required:!1},network:{description:"Stellar network identifier or private network passphrase.",required:!1},horizon:{description:"The URL of the Horizon server.",required:!1},callback:{description:"Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",required:!1},submit:{description:"If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",required:!1,type:Boolean}},returns:["xdr","signed_envelope_xdr","pubkey","tx_signature","network","submit"]},pay:{risk:"high",title:"Make payment",description:"Requests a payment from a user. Works with any Stellar asset, supports transaction memo.",unsafe:!1,implicitFlow:!0,params:{amount:{description:"Requested payment amount.",required:!0},destination:{description:"Payment destination.",required:!0},asset_code:{description:"Asset code (skip for XLM).",required:!1},asset_issuer:{description:"Asset issuer (skip for XLM).",required:!1},memo:{description:"Transaction memo (required for exchanges and some anchors).",required:!1},memo_type:{description:"Transaction memo type.",required:!1},pubkey:{description:"Specific public key requested by the application.",required:!1},network:{description:"Stellar network identifier or private network passphrase.",required:!1},horizon:{description:"The URL of the Horizon server.",required:!1},callback:{description:"Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",required:!1},submit:{description:"If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",required:!1,type:Boolean}},returns:["amount","destination","asset_code","asset_issuer","memo","memo_type","signed_envelope_xdr","pubkey","tx_signature","network","horizon"]},trust:{risk:"low",title:"Establish trustline",description:"Requests permission to create a trustline to a given Stellar asset. Gradually simplifies the process of creating trustlines for anchors, ICOs, and airdrops.",unsafe:!1,implicitFlow:!0,params:{asset_code:{description:"Trustline asset code.",required:!0},asset_issuer:{description:"Trustline asset issuer address.",required:!0},limit:{description:"Trust limit.",required:!1},pubkey:{description:"Specific public key requested by the application.",required:!1},network:{description:"Stellar network identifier or private network passphrase.",required:!1},horizon:{description:"The URL of the Horizon server.",required:!1},callback:{description:"Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",required:!1},submit:{description:"If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",required:!1,type:Boolean}},returns:["asset_code","asset_issuer","limit","signed_envelope_xdr","pubkey","tx_signature","network","horizon"]},exchange:{risk:"high",title:"Purchase tokens",description:"Requests permission to buy tokens on Stellar DEX at market price.",unsafe:!0,implicitFlow:!1,params:{sell_asset_code:{description:"Asset code of the asset to sell.",required:!1},sell_asset_issuer:{description:"Issuer account of the asset to sell.",required:!1},buy_asset_code:{description:"Asset code of the asset to buy.",required:!1},buy_asset_issuer:{description:"Issuer account of the asset to buy.",required:!1},amount:{description:"The amount of asset to buy.",required:!0},max_price:{description:"Maximum price the user willing to pay.",required:!0},pubkey:{description:"Specific public key requested by the application.",required:!1},network:{description:"Stellar network identifier or private network passphrase.",required:!1},horizon:{description:"The URL of the Horizon server.",required:!1},callback:{description:"Optional URL callback where signer will POST signed transaction XDR instead of submitting it to Horizon. ",required:!1},submit:{description:"If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",required:!1,type:Boolean}},returns:["amount","max_price","sell_asset_code","sell_asset_issuer","buy_asset_code","buy_asset_issuer","tx_signature","network","horizon"]},implicit_flow:{risk:"high",title:"Grant session permissions",description:'Requests temporary access token for one or more intents that can be used to execute actions without explicit confirmation from the user. In order to be executed implicitly, an implicit flow permissions for a given intent should be granted and "pubkey" parameter set.',unsafe:!0,implicitFlow:!1,params:{intents:{description:"Requested intents for the implicit flow.",required:!0},network:{description:"Stellar network identifier or private network passphrase.",required:!1}},returns:["granted","intents","session","pubkey","network","valid_until"]}},n={unhandledError:{message:"Unhandled error occurred. If this error persists, please contact our support team.",code:-1},externalError:{message:"External error occurred.",code:-2},invalidIntentRequest:{message:"Intent request is invalid.",code:-3},actionRejectedByUser:{message:"Action request was rejected by the user.",code:-4}},o=i(0);function a(e,t){if(null==e)return{};var i,r,s=function(e,t){if(null==e)return{};var i,r,s={},n=Object.keys(e);for(r=0;r<n.length;r++)i=n[r],t.indexOf(i)>=0||(s[i]=e[i]);return s}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)i=n[r],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(s[i]=e[i])}return s}var c=class{constructor(e,t=!1){this.isLoaded=!1,this.windowHandler=e,this.ephemeral=!!t,this.isLoaded=!1,this.pendingRequests={},this.preprocessRequestParams=null,this.onLoaded=new Promise((e,t)=>this.onLoadedCallback=e),this.messageHandler=this.messageHandler.bind(this),window.addEventListener("message",this.messageHandler,!1)}markLoaded(){if(this.isLoaded=!0,this.onLoadedCallback){const e=this.onLoadedCallback;this.onLoadedCallback=null,e()}}messageHandler({data:e}){if(e.albedo){const{version:t}=e.albedo;return this.markLoaded()}if(e.albedoIntentResult){const t=e.albedoIntentResult,{__reqid:i}=t,r=a(t,["__reqid"]),s=this.pendingRequests[i];s&&(delete this.pendingRequests[i],s(r.error,r),this.ephemeral&&(window.removeEventListener("message",this.messageHandler,!1),this.windowHandler.close()))}}transportCloseHandler(){for(let e in this.pendingRequests)if(this.pendingRequests.hasOwnProperty(e)){const t=this.pendingRequests[e];delete this.pendingRequests[e],t(n.actionRejectedByUser)}}postMessage(e){const t=r();return new Promise((i,r)=>{this.onLoaded.then(()=>{this.pendingRequests[t]=(e,t)=>e?r(e):i(t),e=Object.assign({__reqid:t,__albedo_intent_version:o.version},e),this.preprocessRequestParams&&(e=this.preprocessRequestParams(e)),this.windowHandler.postMessage(e,"*")})})}};let d=null;var l=class{constructor({session:e,pubkey:t,grants:i,valid_until:r}){this.key="",this.pubkey="",this.grants=[],this.validUntil=0,this.key=e,this.pubkey=t,this.grants=i.slice(),this.validUntil=r,Object.freeze(this),Object.freeze(this.grants)}get isExpired(){return this.validUntil-2e3<(new Date).getTime()}toJSON(){return{session:this.key,pubkey:this.pubkey,grants:this.grants.slice(),valid_until:this.validUntil}}},u=new class{constructor(){this.saveToBrowserStorage=!1,this.implicitSessions={},this.saveToBrowserStorage=!0}addSession(e){const t=new l(e);this.saveToBrowserStorage?window.sessionStorage.setItem("albedo_session_"+t.pubkey,JSON.stringify(t)):this.implicitSessions[t.pubkey]=t}getImplicitSession(e,t){let i;if(this.saveToBrowserStorage){const e=window.sessionStorage.getItem("albedo_session_"+t);e&&(i=new l(JSON.parse(e)))}else i=this.implicitSessions[t];return i?i.isExpired?(delete this.implicitSessions[t],null):i.grants.includes(e)?i:null:null}},p=new class{requestIntentConfirmation(e,t){const{intent:i}=e;if(!i)return Promise.reject(new Error('Parameter "intent" is required.'));const r=s[i];if(!r)return Promise.reject(new Error('Unknown intent: "'.concat(i,'".')));let n;try{n=this.prepareRequestParams(r,e)}catch(e){return Promise.reject(e)}return this.sendRequest(n,t)}sendRequest(e,t){let i;if(e.pubkey){const r=u.getImplicitSession(e.intent,e.pubkey);r&&(e.session=r.key,i=function(e){if(!d){const t=document.createElement("iframe");t.style.border="none",Object.assign(t,{width:"0",height:"0",frameBorder:"0",referrerPolicy:"origin",src:"".concat(e,"/implicit")}),document.body.appendChild(t),d=new c(t.contentWindow)}return d}(t))}return i||(i=function(e){const t="".concat(e,"/confirm"),i=void 0!==window.screenLeft?window.screenLeft:window.screenX,r=void 0!==window.screenTop?window.screenTop:window.screenY,s=(window.innerWidth?window.innerWidth:document.documentElement.clientWidth?document.documentElement.clientWidth:screen.width)/2-220+i,n=(window.innerHeight?window.innerHeight:document.documentElement.clientHeight?document.documentElement.clientHeight:screen.height)/2-300+r,o=window.open(t,"auth.albedo.link","height=".concat(600,",width=").concat(440,",top=").concat(n,",left=").concat(s,",menubar=0,toolbar=0,location=0,status=0,personalbar=0,scrollbars=0,dependent=1"));return new c(o,!0)}(t)),i.postMessage(e).then(e=>("implicit_flow"===e.intent&&e.granted&&u.addSession(e),e))}prepareRequestParams(e,t){if("object"!=typeof t)throw new Error("Intent parameters expected.");const{intent:i,pubkey:r}=t,s={intent:i};if(r&&!/^G[0-9A-Z]{55}$/.test(r))throw new Error('Invalid "pubkey" parameter. Stellar account public key expected.');for(const r in e.params){const n=e.params[r],o=t[r];if(o)s[r]=o;else if(n.required)throw new Error('Parameter "'.concat(r,'" is required for intent "').concat(i,'".'))}return s}};if("object"==typeof window&&"function"!=typeof window.fetch)throw new Error("Browser FetchAPI is not available. For legacy browsers support use polyfills such as whatwg-fetch.");class h{constructor(){this.frontendUrl="https://albedo.link"}request(e,t){return p.requestIntentConfirmation(Object.assign(t||{},{intent:e}),this.frontendUrl)}implicitFlow(e){return this.request("implicit_flow",e)}basicInfo(){return this.request("basic_info")}publicKey(e){return e=Object.assign({},e,{token:e.token||this.generateRandomToken()}),this.request("public_key",e)}tx(e){return this.request("tx",e)}pay(e){return this.request("pay",e)}trust(e){return this.request("trust",e)}exchange(e){return this.request("exchange",e)}signMessage(e){return e=Object.assign({},e,{message:m(e.message)}),this.request("sign_message",e)}createKeypair(e){return this.request("create_keypair",e)}generateRandomToken(){return r()}isImplicitSessionAllowed(e,t){return!!u.getImplicitSession(e,t)}}function m(e){switch(typeof e){case"string":return e;case"undefined":return""}return JSON.stringify(e)}h.intentInterface=s,h.intentErrors=n;const b=new h;var f;f=b,"undefined"!=typeof document&&document.addEventListener&&document.addEventListener("click",(function(e){if("A"!==e.target.tagName||0!==(e.target.href||"").indexOf("web+stellar:"))return;e.preventDefault(),e.stopImmediatePropagation();const{pathname:t,search:i}=new URL(e.target.href);if(!["tx","pay"].includes(t))return void alert("Invalid operation requested: ".concat(t,". It's likely an external application error. Please contact support team of ").concat(window.location.origin,"."));const r=function(e=null){null===e&&(e=window.location.search),"?"===e[0]&&(e=e.substr(1));const t={};for(let i of e.split("&")){const[e,r]=i.split("=").map(e=>decodeURIComponent(e));t[e]=r}return t}(i);f.request(t,r)}),!1),t.default=b}])},"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.albedo=t():e.albedo=t();
//# sourceMappingURL=albedo.intent.js.map